// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const checkAppointmentExistsForRule = `-- name: CheckAppointmentExistsForRule :one
SELECT EXISTS(
    SELECT 1 FROM appointments 
    WHERE recurring_rule_id = $1 
    AND date = $2::date
    AND status != 'cancelled'
)
`

type CheckAppointmentExistsForRuleParams struct {
	RecurringRuleID sql.NullInt64 `json:"recurring_rule_id"`
	Column2         time.Time     `json:"column_2"`
}

// Query auxiliar
func (q *Queries) CheckAppointmentExistsForRule(ctx context.Context, arg CheckAppointmentExistsForRuleParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkAppointmentExistsForRule, arg.RecurringRuleID, arg.Column2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAppointment = `-- name: CreateAppointment :one

INSERT INTO appointments (
    professional_id, client_id, date, start_time, duration_minutes, price, status, rescheduled_from_id, recurring_rule_id
)
VALUES ($1, $2, $3, $4, $5, $6, 'scheduled', $7, $8)
RETURNING id, professional_id, client_id, date, start_time, duration_minutes, price, status, rescheduled_from_id, recurring_rule_id, created_at, updated_at
`

type CreateAppointmentParams struct {
	ProfessionalID    int64          `json:"professional_id"`
	ClientID          int64          `json:"client_id"`
	Date              time.Time      `json:"date"`
	StartTime         string         `json:"start_time"`
	DurationMinutes   int32          `json:"duration_minutes"`
	Price             sql.NullString `json:"price"`
	RescheduledFromID sql.NullInt64  `json:"rescheduled_from_id"`
	RecurringRuleID   sql.NullInt64  `json:"recurring_rule_id"`
}

// SECTION: Appointments (Calendar)
// Agregamos 'price' (que viene de la regla o del input manual)
func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, createAppointment,
		arg.ProfessionalID,
		arg.ClientID,
		arg.Date,
		arg.StartTime,
		arg.DurationMinutes,
		arg.Price,
		arg.RescheduledFromID,
		arg.RecurringRuleID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.ProfessionalID,
		&i.ClientID,
		&i.Date,
		&i.StartTime,
		&i.DurationMinutes,
		&i.Price,
		&i.Status,
		&i.RescheduledFromID,
		&i.RecurringRuleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createClient = `-- name: CreateClient :one

INSERT INTO clients (name, email, phone, professional_id, active)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, professional_id, email, phone, active, created_at
`

type CreateClientParams struct {
	Name           string         `json:"name"`
	Email          sql.NullString `json:"email"`
	Phone          sql.NullString `json:"phone"`
	ProfessionalID int64          `json:"professional_id"`
	Active         sql.NullBool   `json:"active"`
}

// SECTION: Clients (Antes Patients)
// Nota: active se pasa explÃ­citamente o se deja default en true
func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (Client, error) {
	row := q.db.QueryRowContext(ctx, createClient,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.ProfessionalID,
		arg.Active,
	)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProfessionalID,
		&i.Email,
		&i.Phone,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const createProfessional = `-- name: CreateProfessional :one

INSERT INTO professionals (name, email, phone, cancellation_window_hours)
VALUES ($1, $2, $3, $4)
RETURNING id, name, email, phone, cancellation_window_hours, created_at
`

type CreateProfessionalParams struct {
	Name                    string         `json:"name"`
	Email                   string         `json:"email"`
	Phone                   sql.NullString `json:"phone"`
	CancellationWindowHours sql.NullInt32  `json:"cancellation_window_hours"`
}

// SECTION: Professionals (Antes Psychologists)
func (q *Queries) CreateProfessional(ctx context.Context, arg CreateProfessionalParams) (Professional, error) {
	row := q.db.QueryRowContext(ctx, createProfessional,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.CancellationWindowHours,
	)
	var i Professional
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.CancellationWindowHours,
		&i.CreatedAt,
	)
	return i, err
}

const createRecurringRule = `-- name: CreateRecurringRule :one

INSERT INTO recurring_rules (professional_id, client_id, day_of_week, start_time, duration_minutes, price, start_date, active)
VALUES ($1, $2, $3, $4, $5, $6, $7, TRUE)
RETURNING id, professional_id, client_id, day_of_week, start_time, duration_minutes, price, active, start_date, created_at
`

type CreateRecurringRuleParams struct {
	ProfessionalID  int64          `json:"professional_id"`
	ClientID        int64          `json:"client_id"`
	DayOfWeek       int32          `json:"day_of_week"`
	StartTime       string         `json:"start_time"`
	DurationMinutes int32          `json:"duration_minutes"`
	Price           sql.NullString `json:"price"`
	StartDate       sql.NullTime   `json:"start_date"`
}

// SECTION: Recurring Rules
// Agregamos 'price' y 'start_date'. Active va fijo en TRUE al crear.
func (q *Queries) CreateRecurringRule(ctx context.Context, arg CreateRecurringRuleParams) (RecurringRule, error) {
	row := q.db.QueryRowContext(ctx, createRecurringRule,
		arg.ProfessionalID,
		arg.ClientID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.DurationMinutes,
		arg.Price,
		arg.StartDate,
	)
	var i RecurringRule
	err := row.Scan(
		&i.ID,
		&i.ProfessionalID,
		&i.ClientID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.DurationMinutes,
		&i.Price,
		&i.Active,
		&i.StartDate,
		&i.CreatedAt,
	)
	return i, err
}

const createScheduleConfig = `-- name: CreateScheduleConfig :one

INSERT INTO schedule_configs (professional_id, day_of_week, start_time, end_time)
VALUES ($1, $2, $3, $4)
RETURNING id, professional_id, day_of_week, start_time, end_time, created_at
`

type CreateScheduleConfigParams struct {
	ProfessionalID int64  `json:"professional_id"`
	DayOfWeek      int32  `json:"day_of_week"`
	StartTime      string `json:"start_time"`
	EndTime        string `json:"end_time"`
}

// SECTION: Schedule Configuration (Availability)
func (q *Queries) CreateScheduleConfig(ctx context.Context, arg CreateScheduleConfigParams) (ScheduleConfig, error) {
	row := q.db.QueryRowContext(ctx, createScheduleConfig,
		arg.ProfessionalID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
	)
	var i ScheduleConfig
	err := row.Scan(
		&i.ID,
		&i.ProfessionalID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.CreatedAt,
	)
	return i, err
}

const deleteScheduleConfigs = `-- name: DeleteScheduleConfigs :exec
DELETE FROM schedule_configs WHERE professional_id = $1
`

func (q *Queries) DeleteScheduleConfigs(ctx context.Context, professionalID int64) error {
	_, err := q.db.ExecContext(ctx, deleteScheduleConfigs, professionalID)
	return err
}

const getActiveRecurringRules = `-- name: GetActiveRecurringRules :many
SELECT r.id, r.professional_id, r.client_id, r.day_of_week, r.start_time, r.duration_minutes, r.price, r.active, r.start_date, r.created_at FROM recurring_rules r
JOIN clients c ON r.client_id = c.id
WHERE r.professional_id = $1 
  AND r.active = TRUE 
  AND c.active = TRUE
`

// Usada por el worker. Solo trae reglas activas de clientes activos.
func (q *Queries) GetActiveRecurringRules(ctx context.Context, professionalID int64) ([]RecurringRule, error) {
	rows, err := q.db.QueryContext(ctx, getActiveRecurringRules, professionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecurringRule
	for rows.Next() {
		var i RecurringRule
		if err := rows.Scan(
			&i.ID,
			&i.ProfessionalID,
			&i.ClientID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.DurationMinutes,
			&i.Price,
			&i.Active,
			&i.StartDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppointment = `-- name: GetAppointment :one
SELECT id, professional_id, client_id, date, start_time, duration_minutes, price, status, rescheduled_from_id, recurring_rule_id, created_at, updated_at FROM appointments WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAppointment(ctx context.Context, id int64) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, getAppointment, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.ProfessionalID,
		&i.ClientID,
		&i.Date,
		&i.StartTime,
		&i.DurationMinutes,
		&i.Price,
		&i.Status,
		&i.RescheduledFromID,
		&i.RecurringRuleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClient = `-- name: GetClient :one
SELECT id, name, professional_id, email, phone, active, created_at FROM clients WHERE id = $1 LIMIT 1
`

func (q *Queries) GetClient(ctx context.Context, id int64) (Client, error) {
	row := q.db.QueryRowContext(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ProfessionalID,
		&i.Email,
		&i.Phone,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const getDayAppointments = `-- name: GetDayAppointments :many
SELECT id, start_time, duration_minutes, status
FROM appointments
WHERE professional_id = $1 
  AND date = $2::date 
  AND status != 'cancelled'
`

type GetDayAppointmentsParams struct {
	ProfessionalID int64     `json:"professional_id"`
	Column2        time.Time `json:"column_2"`
}

type GetDayAppointmentsRow struct {
	ID              int64          `json:"id"`
	StartTime       string         `json:"start_time"`
	DurationMinutes int32          `json:"duration_minutes"`
	Status          sql.NullString `json:"status"`
}

func (q *Queries) GetDayAppointments(ctx context.Context, arg GetDayAppointmentsParams) ([]GetDayAppointmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDayAppointments, arg.ProfessionalID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDayAppointmentsRow
	for rows.Next() {
		var i GetDayAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.StartTime,
			&i.DurationMinutes,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfessional = `-- name: GetProfessional :one
SELECT id, name, email, phone, cancellation_window_hours, created_at FROM professionals 
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetProfessional(ctx context.Context, id int64) (Professional, error) {
	row := q.db.QueryRowContext(ctx, getProfessional, id)
	var i Professional
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.CancellationWindowHours,
		&i.CreatedAt,
	)
	return i, err
}

const getProfessionalByEmail = `-- name: GetProfessionalByEmail :one
SELECT id, name, email, phone, cancellation_window_hours, created_at FROM professionals 
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetProfessionalByEmail(ctx context.Context, email string) (Professional, error) {
	row := q.db.QueryRowContext(ctx, getProfessionalByEmail, email)
	var i Professional
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.CancellationWindowHours,
		&i.CreatedAt,
	)
	return i, err
}

const getProfessionalSettings = `-- name: GetProfessionalSettings :one
SELECT id, cancellation_window_hours 
FROM professionals 
WHERE id = $1
`

type GetProfessionalSettingsRow struct {
	ID                      int64         `json:"id"`
	CancellationWindowHours sql.NullInt32 `json:"cancellation_window_hours"`
}

func (q *Queries) GetProfessionalSettings(ctx context.Context, id int64) (GetProfessionalSettingsRow, error) {
	row := q.db.QueryRowContext(ctx, getProfessionalSettings, id)
	var i GetProfessionalSettingsRow
	err := row.Scan(&i.ID, &i.CancellationWindowHours)
	return i, err
}

const listAppointmentsInDateRange = `-- name: ListAppointmentsInDateRange :many
SELECT a.id, a.professional_id, a.client_id, a.date, a.start_time, a.duration_minutes, a.price, a.status, a.rescheduled_from_id, a.recurring_rule_id, a.created_at, a.updated_at, c.name as client_name
FROM appointments a
JOIN clients c ON a.client_id = c.id
WHERE a.professional_id = $1 
  AND a.date >= $2::date 
  AND a.date <= $3::date
ORDER BY a.date, a.start_time
`

type ListAppointmentsInDateRangeParams struct {
	ProfessionalID int64     `json:"professional_id"`
	Column2        time.Time `json:"column_2"`
	Column3        time.Time `json:"column_3"`
}

type ListAppointmentsInDateRangeRow struct {
	ID                int64          `json:"id"`
	ProfessionalID    int64          `json:"professional_id"`
	ClientID          int64          `json:"client_id"`
	Date              time.Time      `json:"date"`
	StartTime         string         `json:"start_time"`
	DurationMinutes   int32          `json:"duration_minutes"`
	Price             sql.NullString `json:"price"`
	Status            sql.NullString `json:"status"`
	RescheduledFromID sql.NullInt64  `json:"rescheduled_from_id"`
	RecurringRuleID   sql.NullInt64  `json:"recurring_rule_id"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	ClientName        string         `json:"client_name"`
}

// En Postgres usamos $2 y $3 para las fechas.
func (q *Queries) ListAppointmentsInDateRange(ctx context.Context, arg ListAppointmentsInDateRangeParams) ([]ListAppointmentsInDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAppointmentsInDateRange, arg.ProfessionalID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppointmentsInDateRangeRow
	for rows.Next() {
		var i ListAppointmentsInDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfessionalID,
			&i.ClientID,
			&i.Date,
			&i.StartTime,
			&i.DurationMinutes,
			&i.Price,
			&i.Status,
			&i.RescheduledFromID,
			&i.RecurringRuleID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listClients = `-- name: ListClients :many
SELECT id, name, professional_id, email, phone, active, created_at FROM clients
WHERE professional_id = $1 AND active = TRUE
ORDER BY name
`

func (q *Queries) ListClients(ctx context.Context, professionalID int64) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, listClients, professionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProfessionalID,
			&i.Email,
			&i.Phone,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfessionals = `-- name: ListProfessionals :many
SELECT id, name, email, phone
FROM professionals
`

type ListProfessionalsRow struct {
	ID    int64          `json:"id"`
	Name  string         `json:"name"`
	Email string         `json:"email"`
	Phone sql.NullString `json:"phone"`
}

func (q *Queries) ListProfessionals(ctx context.Context) ([]ListProfessionalsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfessionals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProfessionalsRow
	for rows.Next() {
		var i ListProfessionalsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Phone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringRules = `-- name: ListRecurringRules :many
SELECT r.id, r.professional_id, r.client_id, r.day_of_week, r.start_time, r.duration_minutes, r.price, r.active, r.start_date, r.created_at, c.name as client_name
FROM recurring_rules r
JOIN clients c ON r.client_id = c.id
WHERE r.professional_id = $1
ORDER BY r.day_of_week, r.start_time
`

type ListRecurringRulesRow struct {
	ID              int64          `json:"id"`
	ProfessionalID  int64          `json:"professional_id"`
	ClientID        int64          `json:"client_id"`
	DayOfWeek       int32          `json:"day_of_week"`
	StartTime       string         `json:"start_time"`
	DurationMinutes int32          `json:"duration_minutes"`
	Price           sql.NullString `json:"price"`
	Active          sql.NullBool   `json:"active"`
	StartDate       sql.NullTime   `json:"start_date"`
	CreatedAt       sql.NullTime   `json:"created_at"`
	ClientName      string         `json:"client_name"`
}

func (q *Queries) ListRecurringRules(ctx context.Context, professionalID int64) ([]ListRecurringRulesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecurringRules, professionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecurringRulesRow
	for rows.Next() {
		var i ListRecurringRulesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfessionalID,
			&i.ClientID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.DurationMinutes,
			&i.Price,
			&i.Active,
			&i.StartDate,
			&i.CreatedAt,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduleConfigs = `-- name: ListScheduleConfigs :many
SELECT id, professional_id, day_of_week, start_time, end_time, created_at FROM schedule_configs
WHERE professional_id = $1
ORDER BY day_of_week, start_time
`

func (q *Queries) ListScheduleConfigs(ctx context.Context, professionalID int64) ([]ScheduleConfig, error) {
	rows, err := q.db.QueryContext(ctx, listScheduleConfigs, professionalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ScheduleConfig
	for rows.Next() {
		var i ScheduleConfig
		if err := rows.Scan(
			&i.ID,
			&i.ProfessionalID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleRecurringRule = `-- name: ToggleRecurringRule :one
UPDATE recurring_rules
SET active = $1
WHERE id = $2
RETURNING id, professional_id, client_id, day_of_week, start_time, duration_minutes, price, active, start_date, created_at
`

type ToggleRecurringRuleParams struct {
	Active sql.NullBool `json:"active"`
	ID     int64        `json:"id"`
}

func (q *Queries) ToggleRecurringRule(ctx context.Context, arg ToggleRecurringRuleParams) (RecurringRule, error) {
	row := q.db.QueryRowContext(ctx, toggleRecurringRule, arg.Active, arg.ID)
	var i RecurringRule
	err := row.Scan(
		&i.ID,
		&i.ProfessionalID,
		&i.ClientID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.DurationMinutes,
		&i.Price,
		&i.Active,
		&i.StartDate,
		&i.CreatedAt,
	)
	return i, err
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :one
UPDATE appointments
SET status = $1, updated_at = NOW()
WHERE id = $2
RETURNING id, professional_id, client_id, date, start_time, duration_minutes, price, status, rescheduled_from_id, recurring_rule_id, created_at, updated_at
`

type UpdateAppointmentStatusParams struct {
	Status sql.NullString `json:"status"`
	ID     int64          `json:"id"`
}

// Usamos NOW() para Postgres
func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) (Appointment, error) {
	row := q.db.QueryRowContext(ctx, updateAppointmentStatus, arg.Status, arg.ID)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.ProfessionalID,
		&i.ClientID,
		&i.Date,
		&i.StartTime,
		&i.DurationMinutes,
		&i.Price,
		&i.Status,
		&i.RescheduledFromID,
		&i.RecurringRuleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
